/*
 * The AIPlayer class represents AI in the CodeBreaker game.
 * It implements logic into the abstract class,  Player to create codes, make guesses, and provide clues.
 * The AI can operate in different difficulty modes and uses filtering techniques to optimize its guesses.
 */
package CodeBreaker;
import java.io.*;
import java.io.FileReader;
import java.util.*;
public class AIPlayer extends Player {
	private Board b = new Board(); //instantiate the board object named b
	private ArrayList<String> permutations; // all possible permutations of codes
	private ArrayList<String> remainingGuesses; // remaining valid guesses
	private ArrayList<String> possibleClues; // all possible clues
	private static String code; // the secret code generated
	private static boolean participating; // indicates if the AI is active in this round of the codebreaker game
	private String mode;
	/**
     * Constructor initializes the AI player with the specified role and mode and also intializes all necessary attributes .
     * @param boolean codeCreator, indicates if the AI is the code creator.
     * @param String mode, the difficulty mode (easy, medium, hard).
     * @param boolean participating, indicates if the AI is active(participating) this round.
     */
	public AIPlayer(boolean codeCreator, String mode, boolean participating) {
		//initialize attributes from parameters passed in constructors
		this.codeCreator=codeCreator;
		this.participating=participating;
		//initialize Arraylist attributes 
		this.permutations=new ArrayList<>();
		this.remainingGuesses=new ArrayList<>();
		this.possibleClues= new ArrayList<>();
		this.mode=mode;
		loadPermutations(); //initializes the permutations, remainingGuesses and possibleClues attributes by reading from files
	}
	/**
	 * Getter method for the code.
	 * @return String the secret code
	 */
	public String getCode() {
		return code;
	}
    /**
     * Gets the participation status of the AI.
     * @return boolean true, if the AI is participating, otherwise false.
     */
	public static boolean getStatus() {
		return participating;
	}
    /**
     * mandatory Implementation of the giveClue method from the Player class which provides a clue based on the last guess and the code.
     * @return the String clue generated by the AI.
     */
	public String giveClue() {
		ArrayList<String> guesses = new ArrayList<>();
		guesses=b.getGuesses(); //access guesses from board object
		String lastGuess=guesses.get(guesses.size()-1);
		return giveClue(lastGuess,code); //calls helper function
	}
    /**
     * generates a clue for a specific guess and code.
     * @param String guess, the player's guess.
     * @param String code, the secret code.
     * @return String of the generated clue.
     */
	public String giveClue(String guess,String code) {
		String clue=""; //initialize clue variable
		//create local codeChecked and guessChecked arrays of length CODELENGTH
		//this allows us to assign black and white pegs as clues properly without double counting the colours at certain indexes for white pegs by matching the index of the clue and guess with their corresponding index on the boolean codeChecked and guessChecked arrays
		boolean codeChecked[] = new boolean[CODELENGTH]; 
		boolean guessChecked[] = new boolean[CODELENGTH];
		//check for black pegs
		for (int i=0;i<guess.length();i++) { 
			if (guess.charAt(i)==code.charAt(i)) { //check if the character index at guess coresponds with the character index at code
				clue+="b"; //concatenate "b" onto the clue to indicate one black peg
				//codeChecked and guessChecked characters at index i have already been assigned(checked) and given a black peg so mark them as true so we dont worry about them in the next section
				codeChecked[i]=true;
				guessChecked[i]=true;
			}
		}
		//check for white pegs
		for (int i=0;i<guess.length();i++) {
			if (!guessChecked[i]) { //if the character at index i of the guess has already been assigned a peg, we can skip this iteration
				for (int j=0;j<code.length();j++) { //nested for loop to match one index of guess with all indexes of code
					if (!codeChecked[j]&&guess.charAt(i)==code.charAt(j)&&!guessChecked[i]) { //if the code at index j has not been matched with a peg yet and the guess at index i has not been matched with a peg yet(could have happened in the nested j loop so we cant ensure that the outer selection statement prevents this from happening), and the character index at i for guess is equal to the character index at j for code, add a white peg to the clue
						clue+="w"; //concatenate "w" onto clue to indicate white peg
						codeChecked[j]=true; //mark character index at j of code as matched
						guessChecked[i]=true; //mark character index at i of guess as matched
					}
				}
			}
		}
		while(clue.length()<4) { //for remaining, unfilled pegs, fill it with "e" which represents empty(no black or white peg)
			clue+="e"; 
		}
		return clue; 
		
	}
    /**
     * loads permutations and possible clues from files(file handling).
     */
	public void loadPermutations() {
		try {
			//instantiate br objects for different file locations
			BufferedReader br2 = new BufferedReader(new FileReader("codebreaker_combinations.txt")); //contains all the permutations of possible colour combinations
			BufferedReader br3= new BufferedReader(new FileReader("possible_clues.txt")); //contains all the permutations of possible clues 
			String line;
			line=br2.readLine(); //read next line
			while (line!=null) { //while there is info on the line, add the info from that line onto the permutations and remainingGuesses attributes. These two attributes are identical at the start of the program
				permutations.add(line); 
				remainingGuesses.add(line);
				line=br2.readLine(); //reads next line
			}
			line=br3.readLine(); //read line from possible clues file
			while (line!=null) { //while there is info on the next line, add that info to the possibleClues attribute
				possibleClues.add(line);
				line=br3.readLine(); //reads next line
			}
			//close br objects
			br2.close();
			br3.close();
		}
		catch (IOException e) {
			System.out.println(e.getLocalizedMessage()); //print error message
		}
	}
    /**
     * makes a guess based on the AI's difficulty which was initialized in the constructor.
     * @return the String guess made by the AI.
     */
	public String makeGuess() {
		String guess="rrgg"; //for hard mode, this is the first guess
		//local variables used for the minimax algorithm
		int minMax=0;
		String minMaxCode = "";
		int max=0;
		ArrayList<Integer> numSpecificClues= new ArrayList<>(); //number of times a specific clue occurs when doing minimax
		
		String clueGotten;
		ArrayList<String> guesses= b.getGuesses(); //guesses arraylist acquired from board object
		int numGuesses=guesses.size();
		if (mode.equals("hard")) { //if mode is set to hard (filters permutation and uses minimax algorithm)
			if (numGuesses==0) { //if it is the first guess from ai
				remainingGuesses.remove(guess); //remove guess from remainingGuesses
				return guess; 
				
			}
			else {
				filter(); //filters the permutations down based off previous guess and clue
				if (permutations.isEmpty()) { //this means player gave a wrong clue as no more possible permutations remain after their last clue
					return "error"; //return error as string to mark that a wrong clue was given
				}
			}
			//minimax algorithm
			for (int i=0;i<remainingGuesses.size();i++){ //iterate through all remaining guesses
				numSpecificClues.clear(); //reset arraylist after every iteration
				for (int x=0;x<possibleClues.size();x++){
					numSpecificClues.add(0); //initialize values 
				}
				for (int j=0;j<permutations.size();j++){ //iterate through remaining possible permutations
					clueGotten=giveClue(remainingGuesses.get(i),permutations.get(j)); //call the giveClue method to get the clue if code at index j of permutations was actually the secret code
					numSpecificClues.set(possibleClues.indexOf(clueGotten),numSpecificClues.get(possibleClues.indexOf(clueGotten))+1); //add one to the value of the index that corresponds with clueGotten
				}
				//find the largest number in the numSpecificClues arraylist (find the worst case scenario)
				max=numSpecificClues.get(0); //set value at first index to max
				for (int j=1;j<numSpecificClues.size();j++){ 
					if (numSpecificClues.get(j)>max){ //if value at j index is greater
						max=numSpecificClues.get(j); //set it as new max
					}
				}
				//find the best worst case(lowest worst case(max) for all guesses in remainingGuesses)
				if (i==0){ //if it is first index of remainingGuesses
					minMax=max; //set minMax(best worst case) to max
					minMaxCode=remainingGuesses.get(i); //code that yields best worst case
				}
				else{ //if not first index of remainingGuesses
					if (max<minMax){ //if the worst case is less than the previous best worst case
						minMax=max; //assign it to minMax
						minMaxCode=remainingGuesses.get(i); //code that yields best worst case
					}
					else if (max==minMax){ //if the worst case is equal
						if (permutations.contains(remainingGuesses.get(i))){ 
							minMaxCode=remainingGuesses.get(i); //prefer a code that is in permutations so there is a chance that we win when we guess it
						}
					}
				}
			}
			remainingGuesses.remove(minMaxCode); //remove the best worst case from the remainingGuesses attribute
			return minMaxCode; //guess the code that yields the best worst case
		}
		else if (mode.equals("medium")){ //medium mode (filter but no minimax)
			if (numGuesses>0){
				filter(); //filter the guesses
			}
			try {
				guess=permutations.get((int)(Math.random()*permutations.size())); //guess a random code from the permutations after being filtered
			}
			catch (IndexOutOfBoundsException e) { //if there is no more possible permutations
				System.out.println("Error, no more possible permutations. Player has made an error in giving clue");
				guess="error";
			}
			return (guess); //return error as guess
		}
		else{ //easy mode(random guess)
			if (numGuesses>0){
				filter(); //filter to keep track of whether there are remaining permutations (to tell if player has given wrong code)
			}
			int randInt =(int)(Math.random()*remainingGuesses.size());
			guess=remainingGuesses.get(randInt);
			remainingGuesses.remove(guess);
			if (permutations.isEmpty())
				return "error"; //return error if no remaining permutations
			return (guess); //return random guess from remainingGuesses
		}
		
	}
    /**
     * creates a code based on the difficulty mode.
     */
	public void makeCode() {
		String line;
		ArrayList<String> codeOptions = new ArrayList<>();
		try {
			BufferedReader br2;
			//create br object with file location depending on the mode
			if (mode.equals("easy")) {
				br2 = new BufferedReader(new FileReader("easy_mode_codes.txt")); //contains easy to guess clues(2 colours repeating in predictable pattern)
			}
			else if (mode.equals("medium")) {
				br2 = new BufferedReader(new FileReader("medium_mode_codes.txt")); //contains medium clues(have some repeating colours adjacent)
			}
			else{
				br2 = new BufferedReader(new FileReader("hard_mode_codes.txt")); //contains hard clues(all unique colours or unpredictable repeating colours)
			}
			line=br2.readLine(); //read next line in file
			while (line!=null) { //while line has data
				codeOptions.add(line); //store all the codes into arraylist
				line=br2.readLine(); //read next line
			}
			br2.close(); //close br object
		}
		catch (FileNotFoundException e) {
			System.out.println("File not found");
		}
		catch (IOException e) {
			System.out.println("IO Exception encountered");
		}
		int randInt = (int)((Math.random()*codeOptions.size()));
		code=codeOptions.get(randInt); //set the code to a random code within the codeOptions Arraylist
	}
	/**
     * filters permutations based on the latest guess and clue.
     */
	public void filter(){ 
		String lastGuess, lastClue;
		//get clues and guesses from board object and store it in Arraylists
		ArrayList<String> guesses= b.getGuesses();
		ArrayList<String> clues=b.getClues();
		//create arraylist to contain all the codes we must remove from the permutations
		ArrayList<String> remove= new ArrayList<>();
		String returnCode;
		//get last clue and guess
		lastGuess=guesses.get(guesses.size()-1);
		lastClue=clues.get(clues.size()-1);
		for (int i=0;i<permutations.size();i++){ //iterate through possible permutations
			returnCode=giveClue(permutations.get(i),lastGuess); //get the code that would be produced if the lastGuess was the secret code and the value at index i of permutations was the guess
			if (!returnCode.equals(lastClue)){ //if the code returned doesn't match the code given by the code creator, it should be removed from permutations
				remove.add(permutations.get(i)); 
			}
		}
		for (int i=0;i<remove.size();i++) {
			permutations.remove(remove.get(i)); //remove all codes in remove Arraylist from permutations
		}
	}
	/**
	 * checks if the code creator made a mistake while giving clues to the guesser and if there was a mistake, it will be identified and corrected.
	 * @param String code, secret code that was created by the player
	 */
	public void identifyMistake(String code) {
		//get guesses and clues from board object
		ArrayList<String> guesses=b.getGuesses();
		ArrayList<String> clues=b.getClues();
		int iteration=0; 
		//reset permutations, remainingGuesses and possibleClues Arraylists to allow the filter method that is later called to work properly
		permutations.clear();
		remainingGuesses.clear();
		possibleClues.clear();
		loadPermutations();
		while (permutations.indexOf(code)!=-1&&iteration<=10) { //while the max number of guesses is not exceeded and the code is still present in the permutations Arraylist
			//since the filter function uses the last guess and last clue given by the board object, at every iteration, we will add the guesses and clues in the order that they were given by the players. 
			b.addGuess(guesses.get(iteration)); 
			b.addClue(clues.get(iteration));
			filter();
			iteration++;
			//once it is detected that the code is no longer in the permutations Arraylist, it will break out of this while loop, identifying the exact iteration(guess number) where the player gave a wrong clue
		}
		if (iteration<=10) {
			String realClue=giveClue(guesses.get(iteration-1),code); //get the real clue that should have been produced by calling the giveClue method
			System.out.println("Your mistake was on clue #"+iteration+". "+"You gave the clue "+clues.get(iteration-1)+". The real clue should be "+realClue);
		}
		else { //player did not give wrong clue
			System.out.println("No clue giving mistakes");
			b.addClue("all correct"); //add "all correct" to the clue arraylist to indicate that not mistakes were made with clue giving
		}
	}
	/**
	 * extra feature that gives the user a hint when they are guessing ai code.
	 * @param boolean hintGiven, used to check if a hint was already given
	 * @return boolean value of True always since this is a one time use method
	 */
	public static boolean giveHint(boolean hintGiven) {
		if (hintGiven) { //check if hint was given already
			System.out.println("You have already used your one hint");
		}
		else {
			String colours[] = code.split(""); //split the code into array with each colour letter being one index of colours
			int randIndex=(int)(Math.random()*4); //choose a random index to reveal to the player
			String hintCode="";
			for (int i=0;i<code.length();i++) {
				if (i!=randIndex) {
					hintCode+="x"; //add x for the indexes where we will not reveal the colour to the player
				}
				else {
					hintCode+=colours[randIndex]; //add the colour to the index which we will reveal the colour to the player
				}
			}
			System.out.println("x represents unknown colour,"); 
			System.out.println("Your code is "+hintCode);
			
		}
		return true;
	}
	
	
	
}













































